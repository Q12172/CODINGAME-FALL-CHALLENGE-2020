/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/

let Learn = 4;

let CanCastFromAllIngrs = false;

let Commands = [];
let CommandsPrice = 0;
let PossiblesPaths = [];

// game loop
while (true) {
    const actionCount = parseInt(readline()); // the number of spells and recipes in play
    let TimeNow = Date.now();
    let BrewOrders = [];
    let CastOrdersMe = [];
    let CastOrdersOpponent = [];
    let LearningAbleCast = [];
    for (let i = 0; i < actionCount; i++) {
        var inputs = readline().split(' ');
        const actionId = parseInt(inputs[0]); // the unique ID of this spell or recipe
        const actionType = inputs[1]; // in the first league: BREW; later: CAST, OPPONENT_CAST, LEARN, BREW
        const delta0 = parseInt(inputs[2]); // tier-0 ingredient change
        const delta1 = parseInt(inputs[3]); // tier-1 ingredient change
        const delta2 = parseInt(inputs[4]); // tier-2 ingredient change
        const delta3 = parseInt(inputs[5]); // tier-3 ingredient change
        const price = parseInt(inputs[6]); // the price in rupees if this is a potion
        const tomeIndex = parseInt(inputs[7]); // in the first two leagues: always 0; later: the index in the tome if this is a tome spell, equal to the read-ahead tax
        const taxCount = parseInt(inputs[8]); // in the first two leagues: always 0; later: the amount of taxed tier-0 ingredients you gain from learning this spell
        const castable = inputs[9] !== '0'; // in the first league: always 0; later: 1 if this is a castable player spell
        const repeatable = inputs[10] !== '0'; // for the first two leagues: always 0; later: 1 if this is a repeatable player spell
        if(actionType == "CAST"){
            let Free = delta0 >= 0 && delta1 >= 0 && delta2 >= 0 && delta3 >= 0;
            CastOrdersMe.push({castable, ingredients: [delta0, delta1, delta2, delta3], actionId, Free});
        }
        else if(actionType == "OPPONENT_CAST"){
            let Free = delta0 >= 0 && delta1 >= 0 && delta2 >= 0 && delta3 >= 0;
            CastOrdersOpponent.push({castable, ingredients: [delta0, delta1, delta2, delta3], actionId, Free});
        }
        else if(actionType == "BREW"){
            BrewOrders.push({ingredients: [delta0, delta1, delta2, delta3], price, actionId});
        }
        else{
            //Learn
            LearningAbleCast.push({tomeIndex, ingredients: [delta0, delta1, delta2, delta3], taxCount, actionId})
        }
    }

    //inventory
    let CurrIngrMe = Array(4).fill(0);
    let CurrIngrOpponent = Array(4).fill(0);
    for (let i = 0; i < 2; i++) {
        var inputs = readline().split(' ');
        const inv0 = parseInt(inputs[0]); // tier-0 ingredients in inventory
        const inv1 = parseInt(inputs[1]);
        const inv2 = parseInt(inputs[2]);
        const inv3 = parseInt(inputs[3]);
        if(i == 0){
            CurrIngrMe[0] = inv0;
            CurrIngrMe[1] = inv1;
            CurrIngrMe[2] = inv2;
            CurrIngrMe[3] = inv3;
        }
        else{
            CurrIngrOpponent[0] = inv0;
            CurrIngrOpponent[1] = inv1;
            CurrIngrOpponent[2] = inv2;
            CurrIngrOpponent[3] = inv3;
        }
        const score = parseInt(inputs[4]); // amount of rupees
    }

    //console.error(LearningAbleCast)

    if(CanCastFromAllIngrs == false)
        CanCastFromAllIngrs = CanCastFromAllIngredients(CastOrdersMe);

    if(Learn > 0 || CanCastFromAllIngrs == false){
        console.log("LEARN " + LearningAbleCast[0].actionId)
        Learn--;
        continue;
    }

    // if I can Brew A spell than Brew spell
    let Index = CanIBrewSpell(CurrIngrMe, BrewOrders);
    if(Index != -1 && Commands.length == 0){
        console.log("BREW " + BrewOrders[Index].actionId + " Time: "+ (Date.now() - TimeNow));
    }
    else{
        // if I can Cast ingrs the Cast ingrs
        let ArrOutput = CanICastIngrAndThenBrewSpell(LearningAbleCast, CurrIngrMe, BrewOrders, CastOrdersMe);
        let Index = ArrOutput[0];
        if(Index > -1 && CastOrdersMe[Index].castable == false && 
        ArrOutput[2] == undefined){
            if(ArrOutput[1])
                Commands.unshift(Index);
            //I Rest after every Cast
            console.log("REST Time: "+ (Date.now() - TimeNow));
        }
        else if(Index > -1 && ArrOutput[2] == undefined){
            console.log("CAST " + CastOrdersMe[Index].actionId + " Time: "+ (Date.now() - TimeNow));
        }
        else if(Index > -1 && ArrOutput[2] == "LearnCast"){
            //Learn the first spell so I would be able to
            //make potion with him in the next turn
            console.log("LEARN " + LearningAbleCast[Index].actionId + " Time: "+ (Date.now() - TimeNow));
        }
        else{
            //I can't do anything then I Rest
            console.log("REST Time: "+ (Date.now() - TimeNow));
        }
    }
    // Write an action using console.log()
    // To debug: console.error('Debug messages...');


    // in the first league: BREW <id> | WAIT; later: BREW <id> | CAST <id> [<times>] | LEARN <id> | REST | WAIT
}

/*
- Creating a simulation to know which potions I can get to in a definde number of turns or less
- sort by number of turns and the by price
- pick the first path to potion

---------------------------------------------------------------------------------------------------------------------------------------------

//if depth == 0
    // return;

//for every Cast I can make
    //make it
    //if the Cast was ok then check if I can brew a potion with my current inventory
        //if I can
        // Remembr the path I made to reach this potion and remembr the potion price

        //else
        //call the function again with my current inventory (after the Cast) and lower the depth by 1 and add to the path the current action

// Here I have all the potions I can make by using the definded dpeth (number of turns)
// , using just Cast (no include learning, no include resting, no include exhusted)

---------------------------------------------------------------------------------------------------------------------------------------------

//if depth == 0
    // return;

//for every Cast I can make **and the Cast is not exhusted**
    //make it
    //if the Cast was ok then check if I can brew a potion with my current inventory
        //if I can
        // Remembr the path I made to reach this potion and remembr the potion price

        //else
        //make a copy of the list of Casts I can do
        //make the current Cast I used exhusted
        //call the function again with my current inventory (after the Cast) and lower the depth by 1 and add to the path the current action

// Here I have all the potions I can make by using the definded dpeth (number of turns)
//  , using Cast, exhusted (no include learning, no include resting)

---------------------------------------------------------------------------------------------------------------------------------------------

//if depth == 0
    // return;

//One time I do rest and then I preforme the Casts and one time without rest before

//Add to the current path Rest and make a copy of the list of Casts but change every Cast to be not exhusted

//for every Cast I can make and the Cast is not exhusted
    //make it
    //if the Cast was ok then check if I can brew a potion with my current inventory
        //if I can
        //Remembr the path I made to reach this potion and remembr the potion price

        //else
        //make a copy of the list of Casts I can do
        //make the current Cast I used exhusted
        //call the function again with my current inventory (after the Cast) and lower the depth by 1 and add to the path the current action

//Do the same thing but without resting

//for every Cast I can make and the Cast is not exhusted
    //make it
    //if the Cast was ok then check if I can brew a potion with my current inventory
        //if I can
        //Remembr the path I made to reach this potion and remembr the potion price

        //else
        //make a copy of the list of Casts I can do
        //make the current Cast I used exhusted
        //call the function again with my current inventory (after the Cast) and lower the depth by 1 and add to the path the current action

// Here I have all the potions I can make by using the definded dpeth (number of turns)
// , using Cast, rest, exhusted

---------------------------------------------------------------------------------------------------------------------------------------------

//if depth == 0
    // return;

//One time I do rest and then I preforme the Casts and one time without rest before

//Add to the current path Rest and make a copy of the list of Casts but change every Cast to be not exhusted

//for every Cast I can make and the Cast is not exhusted
    //make it
    //if the Cast was ok then check if I can brew a potion with my current inventory
        //if I can
        //Remembr the path I made to reach this potion and remembr the potion price

        //else
        //make a copy of the list of Casts I can do
        //make the current Cast I used exhusted
        //call the function again with my current inventory (after the Cast) and lower the depth by 1 and add to the path the current action

//Do the same thing but without resting

//for every Cast I can make and the Cast is not exhusted
    //make it
    //if the Cast was ok then check if I can brew a potion with my current inventory
        //if I can
        //Remembr the path I made to reach this potion and remembr the potion price

        //else
        //make a copy of the list of Casts I can do
        //make the current Cast I used exhusted
        //call the function again with my current inventory (after the Cast) and lower the depth by 1 and add to the path the current action

//for every Cast I can learn
    //Add to the current path that I learnd
    //learn it and make it
    //if the Cast was ok then check if I can brew a potion with my current inventory
        //if I can
        //Remembr the path I made to reach this potion and remembr the potion price

        //else
        //make a copy of the list of Casts I can do
        //make the current Cast I used exhusted
        //make a copy of the list of learnable Casts I can learn
        //delete the current Cast I learn
        //call the function again with my current inventory (after the Cast) and lower the depth by 1 and add to the path the current action

// Here I have all the potions I can make by using the definded dpeth (number of turns)
// , using Cast, learning, rest, exhusted

*/

function Recursive(CurrIngreds, BrewOrders, CastOrders, LearningAbleCast, depth, Path){

    if(depth == 0){
        return;
    }

    let SavedPath = Path.slice();


    for(let i = 0; i < CastOrders.length; i++){
        if(CastOrders[i].castable == false){
            let SumIngerds = GetSumIngredients(CastOrders[i].ingredients, CurrIngreds);
            if(SumIngerds != undefined){
                let Index = CanIBrewSpell(SumIngerds, BrewOrders);
                if(Index != -1){
                    Path.push("Rest");
                    Path.push(CastOrders[i].actionId);
                    PossiblesPaths.push({Path, Price: BrewOrders[Index].price});
                    Path = SavedPath.slice();
                }
                else{
                    Path.push("Rest");
                    Path.push(CastOrders[i].actionId);
                    Recursive(SumIngerds, BrewOrders, CastOrders, LearningAbleCast, depth - 1, Path);
                    Path = SavedPath.slice();
                }
            }
        }
        else{
            let SumIngerds = GetSumIngredients(CastOrders[i].ingredients, CurrIngreds);
            if(SumIngerds != undefined){
                let Index = CanIBrewSpell(SumIngerds, BrewOrders);
                if(Index != -1){
                    Path.push(CastOrders[i].actionId);
                    PossiblesPaths.push({Path, Price: BrewOrders[Index].price});
                    Path = SavedPath.slice();
                }
                else{
                    Path.push(CastOrders[i].actionId);
                    let CastList = CastOrders.slice();
                    CastOrders[i].castable = false;
                    Recursive(SumIngerds, BrewOrders, CastList, LearningAbleCast, depth - 1, Path);
                    CastOrders[i].castable = true;
                    Path = SavedPath.slice();
                }
            }
        }
    }

    for(let i = 0; i < LearningAbleCast.length; i++){
        if(LearningAbleCast[i].tomeIndex > CurrIngreds[0]){
            continue;
        }
        let TempCurrIngreds = CurrIngreds.slice();
        TempCurrIngreds[0] -= LearningAbleCast[i].tomeIndex;
        let SumIngerds = GetSumIngredients(LearningAbleCast[i].ingredients, CurrIngreds);
        if(SumIngerds != undefined){
            let Index = CanIBrewSpell(SumIngerds, BrewOrders);
            if(Index != -1){
                //Learn
                Path.push(LearningAbleCast[i].actionId);
                //Cast
                Path.push(LearningAbleCast[i].actionId);
                PossiblesPaths.push({Path, Price: BrewOrders[Index].price});
                Path = SavedPath.slice();
            }
            else{
                //Learn
                Path.push(LearningAbleCast[i].actionId);
                //Cast
                Path.push(LearningAbleCast[i].actionId);
                let ListLearningAbleCast = LearningAbleCast.slice();
                ListLearningAbleCast.splice(i,1);
                CastOrders.push(LearningAbleCast[i]);
                CastOrders[CastOrders.length - 1].castable = false;
                Recursive(SumIngerds, BrewOrders, CastOrders, ListLearningAbleCast, depth - 1, Path);
                Path = SavedPath.slice();
                CastOrders.splice(CastOrders.length - 1,1);
            }
        }
    }
}

function CanIBrewSpell(CurrIngrMe, BrewOrders){

    let Index = -1;
    let MaxPrice = 0;

    for(let i = 0; i < BrewOrders.length; i++){
        let ingrs = BrewOrders[i].ingredients;
        let price = BrewOrders[i].price;

        let SumIngredients = GetSumIngredients(ingrs, CurrIngrMe);
        if(SumIngredients != undefined && 
           price > MaxPrice){
            MaxPrice = price;
            Index = i;
        }
    }
    return Index;
}

function MakeCastSoNextTurnsIBrew(CurrIngrMe, BrewOrders, CastOrdersMe, depth, action){

    if(depth == 0){
        return -1;
    }

    /*console.error();
    console.error("action: " + action);
    console.error("CurrIngrMe: ")
    console.error(CurrIngrMe)*/

    for(let i = 0; i < CastOrdersMe.length; i++){

        let CastIngredients = CastOrdersMe[i].ingredients;

        let SumIngredients = GetSumIngredients(CastIngredients, CurrIngrMe);
        if(SumIngredients != undefined){
            let Index = CanIBrewSpell(SumIngredients, BrewOrders);
            if(Index != -1){
                let act = action.slice();
                act.push(i);
                //console.error();
                //console.error("act: " + act);
                //console.error("CurrIngrMe Final: ")
                //console.error(SumIngredients)
                //console.error("BrewOrders: ")
                //console.error(BrewOrders)
                PossiblesPaths.push({action: act, Price: BrewOrders[Index].price});
            }
            else{
                let act = action.slice();
                act.push(i);
                MakeCastSoNextTurnsIBrew(SumIngredients, BrewOrders, CastOrdersMe, depth - 1, act);
            }
        }
    }

    return -1;
}

function CanICastIngrAndThenBrewSpell(LearningAbleCast, CurrIngrMe, BrewOrders, CastOrdersMe){

    PossiblesPaths = [];

    Recursive(CurrIngrMe, BrewOrders, CastOrdersMe, LearningAbleCast, 3, []);

    //sort by turns
    PossiblesPaths.sort((a,b) => a.Path.length - b.Path.length);
    //sort by price
    PossiblesPaths.sort((a,b) => b.Price - a.Price);

    console.error("PossiblesPaths: ");
    console.error(PossiblesPaths);

    if(Commands.length == 0){
        CommandsPrice = 0;
    }

    PossiblesPaths = [];

    //If I can do a Cast that will lead me 
    //to Brew a potion in the next turn
    MakeCastSoNextTurnsIBrew(CurrIngrMe, BrewOrders, CastOrdersMe, 3, []);
    if(PossiblesPaths.length != 0){
        //sort by turns
        PossiblesPaths.sort((a,b) => a.action.length - b.action.length);
        //sort by price
        PossiblesPaths.sort((a,b) => b.Price - a.Price);
        //console.error("PossiblesPaths: ")
        //console.error(PossiblesPaths)
        if((Commands.length == 0 || PossiblesPaths[0].action.length - 1 <= Commands.length) &&
        PossiblesPaths[0].Price > CommandsPrice){
            Commands = PossiblesPaths[0].action;
            CommandsPrice = PossiblesPaths[0].Price;
            //console.error("In " + Commands.length + " turns I Brew!!!")
            return [Commands.splice(0,1)[0], true];
        }
        else{
            return [Commands.splice(0,1)[0], true];
        }
    }

    //console.error("Here")

    //If I can learn the first Cast that will lead me 
    //to Brew a potion in the next turn
    for(let i = 0; i < LearningAbleCast.length; i++){
        let ingrs = LearningAbleCast[0].ingredients;
        if(LearningAbleCast[0].tomeIndex <= CurrIngrMe[0]){
            let SumIngredients = GetSumIngredients(ingrs, CurrIngrMe);
            if(SumIngredients != undefined){
                if(CanIBrewSpell(SumIngredients, BrewOrders) != -1){
                    console.error("Yeah!!!!!")
                    return [i, false, "LearnCast"];
                }
            }
        }
    }
    

    let Min = 100;

    let Index = -1;

    for(let i = 0; i < CastOrdersMe.length; i++){

        let CastIngredients = CastOrdersMe[i].ingredients;

        let SumIngredients = GetSumIngredients(CastIngredients, CurrIngrMe);
        if(SumIngredients != undefined){
            let CurrMin = 0;
            
            //Find the biggest differnce between ingredients
            for(let i = 0; i < SumIngredients.length; i++){
                let ingrA = SumIngredients[i];
                for(let j = i + 1; j < SumIngredients.length; j++){
                    let ingrB = SumIngredients[j];
                    let diff = Math.abs(ingrA - ingrB);
                    if(diff > CurrMin){
                        CurrMin = diff;
                    }
                }
            }
            

            if(CurrMin >= Min){
                continue;
            }
            
            Min = CurrMin;
            Index = i;
        }
    }

    return [Index, false];
}

function CanCastFromAllIngredients(CastOrdersMe){

    let CanCastIngrs = Array(4).fill(0);

    CastOrdersMe.forEach((x) => {
        x.ingredients.forEach((v, index) => {
            if(v < 0){
                CanCastIngrs[index] = 1;
            }
        })

    })

    return CanCastIngrs.every(x => x == 1);
}

function GetSumIngredients(Ingredients1, Ingredients2){

    let arr = [];
    let sum = 0;

    for(let i = 0; i < Ingredients2.length; i++){
        arr[i] = Ingredients2[i] + Ingredients1[i];
        sum += arr[i];
    }

    //Check if there are more than 10 ingredients
    if(sum > 10){
        return undefined;
    }

    //I have negative ingredients
    if(arr.every(x => x >= 0) == false){
        return undefined;
    }

    return arr;
}
