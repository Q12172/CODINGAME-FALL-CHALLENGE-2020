/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/

let Learned = -1;

let InventoryRecursive = [];

let BrewOrders = [];

let Learn = 9;

let CanCastFromAllIngrs = false;

let Commands = [];
let CommandsPrice = 0;
let PossiblesPaths = [];
let PossiblesPathsOp = [];

let OldScoreOp = 0;
let OldScoreMe = 0;

let NumberOfPotionsMadeByMe = 0;
let NumberOfPotionsMadeByOp = 0;

let TimeNow = 0;

// game loop
while (true) {
    let IsTargetExist = false;
    let IsLearnExist = true;
    for(let i = 0; i < Commands.length; i++){
        if(Commands[i].includes("Learn")){
            IsLearnExist = false;
            break;
        }
    }
    const actionCount = parseInt(readline()); // the number of spells and recipes in play
    TimeNow = Date.now();
    BrewOrders = [];
    let CastOrdersMe = [];
    let CastOrdersOpponent = [];
    let LearningAbleCast = [];
    for (let i = 0; i < actionCount; i++) {
        var inputs = readline().split(' ');
        const actionId = parseInt(inputs[0]); // the unique ID of this spell or recipe
        const actionType = inputs[1]; // in the first league: BREW; later: CAST, OPPONENT_CAST, LEARN, BREW
        const delta0 = parseInt(inputs[2]); // tier-0 ingredient change
        const delta1 = parseInt(inputs[3]); // tier-1 ingredient change
        const delta2 = parseInt(inputs[4]); // tier-2 ingredient change
        const delta3 = parseInt(inputs[5]); // tier-3 ingredient change
        const price = parseInt(inputs[6]); // the price in rupees if this is a potion
        const tomeIndex = parseInt(inputs[7]); // in the first two leagues: always 0; later: the index in the tome if this is a tome spell, equal to the read-ahead tax
        const taxCount = parseInt(inputs[8]); // in the first two leagues: always 0; later: the amount of taxed tier-0 ingredients you gain from learning this spell
        const castable = inputs[9] !== '0'; // in the first league: always 0; later: 1 if this is a castable player spell
        const repeatable = inputs[10] !== '0'; // for the first two leagues: always 0; later: 1 if this is a repeatable player spell
        if(actionType == "CAST"){
            CastOrdersMe.push({castable, ingredients: [delta0, delta1, delta2, delta3], actionId, repeatable});
        }
        else if(actionType == "OPPONENT_CAST"){
            CastOrdersOpponent.push({castable, ingredients: [delta0, delta1, delta2, delta3], actionId, repeatable});
        }
        else if(actionType == "BREW"){
            if(Commands.length != 0 && parseInt(Commands[Commands.length - 1].split(' ')[1]) == actionId){
                IsTargetExist = true;
            }
            BrewOrders.push({ingredients: [delta0, delta1, delta2, delta3], price, actionId});
        }
        else{
            if(IsLearnExist == false){
                for(let i = 0; i < Commands.length; i++){
                    if(Commands[i].includes("Learn")){
                        if(actionId == parseInt(Commands[i].split(' ')[1])){
                            IsLearnExist = true;
                            break;
                        }
                    }
                }
            }
            //Learn
            LearningAbleCast.push({taxCount, tomeIndex, ingredients: [delta0, delta1, delta2, delta3], taxCount, actionId, repeatable, castable})
        }
    }

    if(Learned != -1){
        for(let i = 0; i < Commands.length; i++){
            if(parseInt(Commands[i]) == Learned){
                Commands[i] = "" + CastOrdersMe[CastOrdersMe.length - 1].actionId;
            }
            else if(Commands[i].includes("CAST")){
                let Actions = Commands[i].split(' ');
                let ActionId = parseInt(Actions[1]);
                if(ActionId == Learned)
                    Commands[i] = "CAST " + CastOrdersMe[CastOrdersMe.length - 1].actionId + " " + parseInt(Actions[2]);
            }
        }
        Learned = -1;
    }

    //inventory
    let CurrIngrMe = [];
    let CurrIngrOpponent = [];
    for (let i = 0; i < 2; i++) {
        var inputs = readline().split(' ');
        const inv0 = parseInt(inputs[0]); // tier-0 ingredients in inventory
        const inv1 = parseInt(inputs[1]);
        const inv2 = parseInt(inputs[2]);
        const inv3 = parseInt(inputs[3]);
        const score = parseInt(inputs[4]); // amount of rupees
        if(i == 0){
            CurrIngrMe = [inv0, inv1, inv2, inv3];
            if(score != OldScoreMe){
                OldScoreMe = score;
                NumberOfPotionsMadeByMe++;
            }
        }
        else{
            CurrIngrOpponent = [inv0, inv1, inv2, inv3];
            if(score != OldScoreOp){
                OldScoreOp = score;
                NumberOfPotionsMadeByOp++;
            }
        }
    }

    if(IsTargetExist == false || IsLearnExist == false){
        Commands = [];
    }

    //console.error(LearningAbleCast)

    //if(CanCastFromAllIngrs == false)
        //CanCastFromAllIngrs = CanCastFromAllIngredients(CastOrdersMe);

    if(Learn > 0){//(Learn > 0 || CanCastFromAllIngrs == false) && Learn > 0){
        console.log("LEARN " + LearningAbleCast[0].actionId)
        Learn--;
        continue;
    }


    let Output = CanICastIngrAndThenBrewSpell(CurrIngrMe, CastOrdersMe, CurrIngrOpponent, CastOrdersOpponent);
    if(Output[1] == false){
        let Index = Output[0];
        if(Index != -1 && CastOrdersMe[Index].castable == true){
            console.log("CAST " + CastOrdersMe[Index].actionId + " Time: "+ (Date.now() - TimeNow));
        }
        else{
            console.log("REST Time: "+ (Date.now() - TimeNow));
        }
    }
    else{
        //console.error();
        //console.error("Price: "+CommandsPrice);
        if(Output[0] == "Rest"){
            console.log("REST Time: "+ (Date.now() - TimeNow));
        }
        else if(Output[0].includes("Brew")){
            let ActionId = parseInt(Output[0].split(' ')[1]);
            console.log("BREW " + ActionId + " Time: "+ (Date.now() - TimeNow));
        }
        else if(Output[0].includes("CAST")){
            let Actions = Output[0].split(' ');
            let times = parseInt(Actions[2]);
            let ActionId = parseInt(Actions[1]);
            console.log("CAST " + ActionId + " " + times +  " Time: "+ (Date.now() - TimeNow));
        }
        else if(Output[0].includes("Learn")){
            let ActionId = parseInt(Output[0].split(" ")[1]);
            console.log("LEARN " + ActionId + " Yay!!!! Time: "+ (Date.now() - TimeNow));
            Learned = ActionId;
        }
        else{
            let ActionId = parseInt(Output[0]);
            console.log("CAST " + ActionId + " Time: "+ (Date.now() - TimeNow));
        }
    }

    // Write an action using console.log()
    // To debug: console.error('Debug messages...');


    // in the first league: BREW <id> | WAIT; later: BREW <id> | CAST <id> [<times>] | LEARN <id> | REST | WAIT
}

function PredictOpponent(CurrIngreds, CastOrders, depth, monePath){

    if(Date.now() - TimeNow >= 48){
        return;
    }

    if(HaveThisInventoryAlready(CurrIngreds, CastOrders)){
        //console.error("ReduceTime!!!!");
        return;
    }

    InventoryRecursive.push(CurrIngreds);
    InventoryRecursive.push(CastOrders);

    if(depth == 0){
        return;
    }

    for(let i = 0; i < CastOrders.length; i++){
        let NumberOfCasts = 1;
        let CastSpell = CastOrders[i];
        if(CastSpell.castable == false){
            while(true){
                let mone = 1;
                if(NumberOfCasts > 1 && CastSpell.repeatable == false){
                    break;
                }
                let SumIngerds = GetSumIngredients(CastSpell.ingredients, CurrIngreds);
                while(mone != NumberOfCasts){
                    SumIngerds = GetSumIngredients(CastSpell.ingredients, SumIngerds);
                    mone++;
                }

                if(SumIngerds != undefined){
                    let Index = CanIBrewSpell(SumIngerds);

                    if(Index != -1){
                        
                        PossiblesPathsOp.push({PathLen: monePath + 3, Id: BrewOrders[Index].actionId});
                    }
                    else{
                        /*let RememberCastable = [];
                        for(let j = 0; j < CastOrders.length; j++){
                            RememberCastable.push(CastOrders[j].castable);
                            CastOrders[j].castable = true;
                        }*/
                        PredictOpponent(SumIngerds, CastOrders, depth - 1, monePath + 2);
                        /*for(let j = 0; j < RememberCastable.length; j++){
                            CastOrders[j].castable = RememberCastable[j];
                        }*/
                    }

                    NumberOfCasts++;
                }
                else{
                    break;
                }
            }
        }
        else{
            while(true){
                let mone = 1;
                if(NumberOfCasts > 1 && CastSpell.repeatable == false){
                    break;
                }
                let SumIngerds = GetSumIngredients(CastSpell.ingredients, CurrIngreds);
                while(mone != NumberOfCasts){
                    SumIngerds = GetSumIngredients(CastSpell.ingredients, SumIngerds);
                    mone++;
                }

                if(SumIngerds != undefined){
                    let Index = CanIBrewSpell(SumIngerds);

                    if(Index != -1){
                        PossiblesPathsOp.push({PathLen: monePath + 2, Id: BrewOrders[Index].actionId});
                    }
                    else{
                        CastOrders[i].castable = false;
                        PredictOpponent(SumIngerds, CastOrders, depth - 1, monePath + 1);
                        CastOrders[i].castable = true;
                    }
                }
                else{
                    break;
                }

                NumberOfCasts++;
            }
        }
    }
}

function Recursive(CurrIngreds, CastOrders, depth, Path){

    if(Date.now() - TimeNow >= 48){
        return;
    }

    if(HaveThisInventoryAlready(CurrIngreds, CastOrders)){
        //console.error("ReduceTime!!!!");
        return;
    }

    InventoryRecursive.push(CurrIngreds);
    InventoryRecursive.push(CastOrders);

    if(depth == 0){
        return;
    }

    let SavedPath = Path.slice();

    for(let i = 0; i < CastOrders.length; i++){
        let NumberOfCasts = 1;
        let CastSpell = CastOrders[i];
        if(CastSpell.castable == false){
            while(true){
                let mone = 1;
                if(NumberOfCasts > 1 && CastSpell.repeatable == false){
                    break;
                }
                let SumIngerds = GetSumIngredients(CastSpell.ingredients, CurrIngreds);
                while(mone != NumberOfCasts){
                    SumIngerds = GetSumIngredients(CastSpell.ingredients, SumIngerds);
                    mone++;
                }

                if(SumIngerds != undefined){
                    let Index = CanIBrewSpell(SumIngerds);
                    Path.push("Rest");
                    if(NumberOfCasts == 1)
                        Path.push("" + CastSpell.actionId);
                    else
                        Path.push("CAST " + CastSpell.actionId + " " + NumberOfCasts);
                    if(Index != -1){
                        Path.push("Brew " + BrewOrders[Index].actionId);
                        let Price = BrewOrders[Index].price;

                        if(PossiblesPaths[Price] == undefined){
                            PossiblesPaths[Price] = {Path, Price};
                        }
                        else if(PossiblesPaths[Price].length > Path.length){
                            PossiblesPaths[Price] = {Path, Price};
                        }
                        Path = SavedPath.slice();
                    }
                    else{
                        /*let RememberCastable = [];
                        for(let j = 0; j < CastOrders.length; j++){
                            RememberCastable.push(CastOrders[j].castable);
                            CastOrders[j].castable = true;
                        }*/
                        Recursive(SumIngerds, CastOrders, depth - 1, Path);
                        /*for(let j = 0; j < RememberCastable.length; j++){
                            CastOrders[j].castable = RememberCastable[j];
                        }*/
                        Path = SavedPath.slice();
                    }

                    NumberOfCasts++;
                }
                else{
                    break;
                }
            }
        }
        else{
            while(true){
                let mone = 1;
                if(NumberOfCasts > 1 && CastSpell.repeatable == false){
                    break;
                }
                let SumIngerds = GetSumIngredients(CastSpell.ingredients, CurrIngreds);
                while(mone != NumberOfCasts){
                    SumIngerds = GetSumIngredients(CastSpell.ingredients, SumIngerds);
                    mone++;
                }

                if(SumIngerds != undefined){
                    let Index = CanIBrewSpell(SumIngerds);
                    if(NumberOfCasts == 1)
                        Path.push("" + CastSpell.actionId);
                    else
                        Path.push("CAST " + CastSpell.actionId + " " + NumberOfCasts);

                    if(Index != -1){
                        Path.push("Brew " + BrewOrders[Index].actionId);
                        let Price = BrewOrders[Index].price;

                        if(PossiblesPaths[Price] == undefined){
                            PossiblesPaths[Price] = {Path, Price};
                        }
                        else if(PossiblesPaths[Price].length > Path.length){
                            PossiblesPaths[Price] = {Path, Price};
                        }
                        Path = SavedPath.slice();
                    }
                    else{
                        CastOrders[i].castable = false;
                        Recursive(SumIngerds, CastOrders, depth - 1, Path);
                        CastOrders[i].castable = true;
                        Path = SavedPath.slice();
                    }
                }
                else{
                    break;
                }

                NumberOfCasts++;
            }
        }
    }

    /*for(let i = LearningAbleCast.length - 1; i > -1; i--){
        let NumberOfCasts = 1;
        let LearnCast = LearningAbleCast[i];
        if(LearnCast.tomeIndex > CurrIngreds[0]){
            continue;
        }
        while(true){
            let mone = 1;
            if(NumberOfCasts > 1 && LearnCast.repeatable == false){
                break;
            }
            CurrIngreds[0] -= LearnCast.tomeIndex;
            CurrIngreds[0] += LearnCast.taxCount;
            let SumIngerds = GetSumIngredients(LearnCast.ingredients, CurrIngreds);
            CurrIngreds[0] += LearnCast.tomeIndex;
            CurrIngreds[0] -= LearnCast.taxCount;

            while(mone != NumberOfCasts){
                SumIngerds = GetSumIngredients(LearnCast.ingredients, SumIngerds);
                mone++;
            }

            if(SumIngerds != undefined){
                let Index = CanIBrewSpell(SumIngerds);
                //Learn
                Path.push("Learn " + LearnCast.actionId);
                //Cast
                if(NumberOfCasts == 1)
                    Path.push("" + LearnCast.actionId);
                else
                    Path.push("CAST " +  LearnCast.actionId + " " + NumberOfCasts);
                if(Index != -1){
                    Path.push("Brew " + BrewOrders[Index].actionId);
                    let Price = BrewOrders[Index].price;
                    if(PossiblesPaths[Price] == undefined){
                        PossiblesPaths[Price] = {Path, Price};
                    }
                    else if(PossiblesPaths[Price].length > Path.length){
                        PossiblesPaths[Price] = {Path, Price};
                    }
                    Path = SavedPath.slice();
                }
                else{
                    LearnCast.castable = false;
                    CastOrders.push(LearnCast);
                    Recursive(SumIngerds, CastOrders, LearningAbleCast, depth - 1, Path);
                    Path = SavedPath.slice();
                    CastOrders.splice(CastOrders.length - 1,1);
                }
            }
            else{
                break;
            }

            NumberOfCasts++;
        }
    }*/

}

function CanICastIngrAndThenBrewSpell(CurrIngrMe, CastOrdersMe, CurrIngrOpponent, CastOrdersOpponent){

    PossiblesPaths = [];

    InventoryRecursive = [];

    Recursive(CurrIngrMe, CastOrdersMe, 4, []);

    console.error("Commands: ")
    console.error(Commands)
    console.error()

    if((NumberOfPotionsMadeByOp == 5 || NumberOfPotionsMadeByMe == 5) && OldScoreMe > OldScoreOp){
        //sort by shortest path
        PossiblesPaths.sort((a,b) => {
            return b.Price - a.Price;
        });
        //sort by shortest path
        PossiblesPaths.sort((a,b) => {
            return a.Path.length - b.Path.length;
        });
        //console.error("shortest PossiblesPaths: ");
        //console.error(PossiblesPaths);
        if(PossiblesPaths.length > 0){
            let BestPath = PossiblesPaths[0].Path;
            let BestPrice = PossiblesPaths[0].Price;
            if(Commands.length == 0 || 
            Commands.length > BestPath.length ||
            (Commands.length == BestPath.length &&
            CommandsPrice < BestPrice)){
                Commands = BestPath;
                CommandsPrice = BestPrice;
                return [Commands.splice(0,1)[0], true];
            }
            else{
                return [Commands.splice(0,1)[0], true];
            }
        }
    }

    PossiblesPathsOp = [];
    InventoryRecursive = [];

    //PredictOpponent(CurrIngrOpponent, CastOrdersOpponent, 1, 0);

    //console.error("PossiblesPathsOp: ");
    //console.error(PossiblesPathsOp);
    //console.error();


    //sort
    PossiblesPaths.sort((a,b) => {
        return (b.Price / b.Path.length) - (a.Price / a.Path.length);
    });

    //console.error("PossiblesPaths: ");
    //console.error(PossiblesPaths);
    //console.error();

    if(PossiblesPaths.length > 0){
        let Index = 0;
        let BestPath = PossiblesPaths[Index].Path;
        let BestPrice = PossiblesPaths[Index].Price;

        if(Commands.length == 0){

            let check = true;

            while(check && Index + 1 < PossiblesPaths.length && 
            PossiblesPaths[Index + 1] != undefined){
                check = false;
                for(let i = 0; i < PossiblesPathsOp.length; i++){
                    if(parseInt(BestPath[BestPath.length - 1].split(" ")[1]) == PossiblesPathsOp[i].Id
                    && BestPath.length > PossiblesPathsOp[i].PathLen){
                        //console.error("Change because enemy is closer to target!!!")
                        Index++;
                        BestPath = PossiblesPaths[Index].Path;
                        BestPrice = PossiblesPaths[Index].Price;
                        check = true;
                        break;
                    }
                }
            }

            if(Index < PossiblesPaths.length){
                Commands = BestPath;
                CommandsPrice = BestPrice;
                return [Commands.splice(0,1)[0], true];
            }
        }
        else{
            if((BestPrice / BestPath.length) > (CommandsPrice / Commands.length) || 
            (Commands.length == 1 && Commands.length + 1 == BestPath.length && BestPrice > CommandsPrice)){

                let check = false;

                for(let i = 0; i < PossiblesPathsOp.length; i++){
                    if(parseInt(BestPath[BestPath.length - 1].split(" ")[1]) == PossiblesPathsOp[i].Id
                    && BestPath.length > PossiblesPathsOp[i].PathLen){
                        //console.error("Change because enemy is closer to target!!!")
                        check = true;
                        break;
                    }
                }

                if(!check){
                    //console.error("CHANGE!!!!!!!!!!!!!!")
                    Commands = BestPath;
                    CommandsPrice = BestPrice;
                    return [Commands.splice(0,1)[0], true];
                }
                else{

                    let check = false;

                    for(let i = 0; i < PossiblesPathsOp.length; i++){
                        if(parseInt(Commands[Commands.length - 1].split(" ")[1]) == PossiblesPathsOp[i].Id
                        && BestPath.length < PossiblesPathsOp[i].PathLen){
                            //console.error("Change because enemy is closer to target!!!")
                            check = true;
                            break;
                        }
                    }

                    if(!check)
                        return [Commands.splice(0,1)[0], true];
                    else{
                        let Index = 0;
                        let BestPath = PossiblesPaths[Index].Path;
                        let BestPrice = PossiblesPaths[Index].Price;

                        let check = true;
                        while(check && Index + 1 < PossiblesPaths.length &&
                        PossiblesPaths[Index + 1] != undefined){
                            check = false;
                            for(let i = 0; i < PossiblesPathsOp.length; i++){
                                if(parseInt(BestPath[BestPath.length - 1].split(" ")[1]) == PossiblesPathsOp[i].Id
                                && BestPath.length < PossiblesPathsOp[i].PathLen){
                                    //console.error("Change because enemy is closer to target!!!")
                                    Index++;
                                    BestPath = PossiblesPaths[Index].Path;
                                    BestPrice = PossiblesPaths[Index].Price;
                                    check = true;
                                    break;
                                }
                            }
                        }

                        if(Index < PossiblesPaths.length){
                            Commands = BestPath;
                            CommandsPrice = BestPrice;
                            return [Commands.splice(0,1)[0], true];
                        }
                    }
                }
            }
            else{
                let check = false;

                for(let i = 0; i < PossiblesPathsOp.length; i++){
                    if(parseInt(Commands[Commands.length - 1].split(" ")[1]) == PossiblesPathsOp[i].Id
                    && BestPath.length > PossiblesPathsOp[i].PathLen){
                        //console.error("Change because enemy is closer to target!!!")
                        check = true;
                        break;
                    }
                }
                if(!check)
                    return [Commands.splice(0,1)[0], true];
                else{
                    let Index = 0;
                    let BestPath = PossiblesPaths[Index].Path;
                    let BestPrice = PossiblesPaths[Index].Price;
                    let check = true;
                    while(check && Index + 1 < PossiblesPaths.length &&
                    PossiblesPaths[Index + 1] != undefined){
                        check = false;
                        for(let i = 0; i < PossiblesPathsOp.length; i++){
                            if(parseInt(BestPath[BestPath.length - 1].split(" ")[1]) == PossiblesPathsOp[i].Id
                            && BestPath.length > PossiblesPathsOp[i].PathLen){
                                //console.error("Change because enemy is closer to target!!!")
                                Index++;
                                BestPath = PossiblesPaths[Index].Path;
                                BestPrice = PossiblesPaths[Index].Price;
                                check = true;
                                break;
                            }
                        }
                    }
                    if(Index < PossiblesPaths.length){
                        Commands = BestPath;
                        CommandsPrice = BestPrice;
                        return [Commands.splice(0,1)[0], true];
                    }
                }
            }
        }
    }

    /*let Max = 0;

    let Index = -1;
    
    for(let i = 0; i < CastOrdersMe.length; i++){
        let CastIngredients = CastOrdersMe[i].ingredients;
        let SumIngredients = GetSumIngredients(CastIngredients, CurrIngrMe);
        if(SumIngredients != undefined){
            let M = SumIngredients[0] + SumIngredients[1] +
            SumIngredients[2] + SumIngredients[3];
            if(M > Max){
                Max = M;
                Index = i;
            }
        }
    }

    return [Index, false];*/

    let Min = 100;

    let Index = -1;

    for(let i = 0; i < CastOrdersMe.length; i++){

        let CastIngredients = CastOrdersMe[i].ingredients;

        let SumIngredients = GetSumIngredients(CastIngredients, CurrIngrMe);
        if(SumIngredients != undefined){
            let CurrMin = 0;
            
            //Find the biggest differnce between ingredients
            for(let i = 0; i < SumIngredients.length; i++){
                let ingrA = SumIngredients[i];
                for(let j = i + 1; j < SumIngredients.length; j++){
                    let ingrB = SumIngredients[j];
                    let diff = Math.abs(ingrA - ingrB);
                    if(diff > CurrMin){
                        CurrMin = diff;
                    }
                }
            }
            

            if(CurrMin >= Min){
                continue;
            }
            
            Min = CurrMin;
            Index = i;
        }

        
    }

    return [Index, false];
}

function HaveThisInventoryAlready(CurrIngreds, CastOrders){

    for(let i = 0; i < InventoryRecursive.length; i+=2){
        if(CurrIngreds.every((x,j) => InventoryRecursive[i][j] == x) && 
         CastOrders.every((x) => {
             x.castable == InventoryRecursive[i + 1].castable &&
             x.ingredients[0] == InventoryRecursive[i + 1].ingredients[0] &&
             x.ingredients[1] == InventoryRecursive[i + 1].ingredients[1] &&
             x.ingredients[2] == InventoryRecursive[i + 1].ingredients[2] &&
             x.ingredients[3] == InventoryRecursive[i + 1].ingredients[3]
         }) && InventoryRecursive[i + 1].length == CastOrders.length)
            return true;
    }

    return false;
}

function CanIBrewSpell(CurrIngrMe){

    let Index = -1;
    let MaxPrice = 0;

    for(let i = 0; i < BrewOrders.length; i++){
        let price = BrewOrders[i].price;

        if(GetSumIngredients(BrewOrders[i].ingredients, CurrIngrMe) != undefined && 
           price > MaxPrice){
            MaxPrice = price;
            Index = i;
        }
    }
    return Index;
}

function CanCastFromAllIngredients(CastOrdersMe){

    let CanCastIngrs = Array(4).fill(0);

    CastOrdersMe.forEach((x) => {
        x.ingredients.forEach((v, index) => {
            if(v < 0){
                CanCastIngrs[index] = 1;
            }
        })

    })

    return CanCastIngrs.every(x => x == 1);
}

function GetSumIngredients(Ingredients1, Ingredients2){

    let arr = [];
    let sum = 0;

    for(let i = 0; i < Ingredients2.length; i++){
        arr[i] = Ingredients2[i] + Ingredients1[i];
        sum += arr[i];
        if(arr[i] < 0){
            //I have negative ingredients
            return undefined;
        }
    }

    //Check if there are more than 10 ingredients
    if(sum > 10){
        return undefined;
    }

    return arr;
}
