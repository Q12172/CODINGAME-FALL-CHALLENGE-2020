using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;


/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Node<T>{

    public Node<T> Before;
    public T value;
    public Node<T> Next;

    public Node(T value, Node<T> Before)
    {
        this.value = value;
        Next = null;
        this.Before = Before;
    }
    public Node(T value)
    {
        this.value = value;
        Next = null;
        Before = null;
    }

    public Node<T> GetLastNode(Node<T> Node){
        while(Node.Next != null){
            Node = Node.Next;
        }
        return Node;
    }
}

class LearnSpell{

    public bool castable;
    public int[] ingredients;
    public int actionId;
    public bool repeatable;
    public int tomeIndex;

    public LearnSpell(bool castable, int[] ingredients, int actionId, bool repeatable, int tomeIndex)
    {
        this.castable = castable;
        this.ingredients = ingredients;
        this.actionId = actionId;
        this.repeatable = repeatable;
        this.tomeIndex = tomeIndex;
    }

}

class Spell{

    public bool castable;
    public int[] ingredients;
    public int actionId;
    public bool Free;
    public bool repeatable;

    public Spell(bool castable, int[] ingredients, int actionId, bool Free, bool repeatable)
    {
        this.castable = castable;
        this.ingredients = ingredients;
        this.actionId = actionId;
        this.Free = Free;
        this.repeatable = repeatable;
    }

}

class Order{

    public int[] ingredients;
    public int price;
    public int actionId;

    public Order(int[] ingredients, int price, int actionId){

        this.ingredients = ingredients;
        this.price = price;
        this.actionId = actionId;
    }

}


class Player
{
    static void Main(string[] args)
    {
        string[] inputs;

        int Learned = -1;

        //int[] InventoryRecursive = new int [?];

        Node<Order> FirstBrewOrders = null;

        int Learn = 8;

        bool CanCastFromAllIngrs = false;

        Node<string> FirstCommand = null;
        int CommandsPrice = 0;
        Node<Node<string>> FirstPossiblesPaths = null;

        int OldScoreOp = 0;
        int OldScoreMe = 0;

        int NumberOfPotionsMadeByMe = 0;
        int NumberOfPotionsMadeByOp = 0;

        int TimeNow = 0;

        // game loop
        while (true)
        {
            Node<string> Command = FirstCommand;
            bool IsTargetExist = false;
            bool IsLearnExist = true;
            while(Command != null){
                if(Command.value.Contains("Learn")){
                    IsLearnExist = false;
                    break;
                }
                Command = Command.Next;
            }
            int actionCount = int.Parse(Console.ReadLine()); // the number of spells and recipes in play
            TimeNow = DateTime.Now.Millisecond;
            FirstBrewOrders = null;
            Node<Spell> FirstCastOrdersMe = null;
            //Node<Spell> CastOrdersOpponent = null;
            Node<LearnSpell> FirstLearningAbleCast = null;
            for (int i = 0; i < actionCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int actionId = int.Parse(inputs[0]); // the unique ID of this spell or recipe
                string actionType = inputs[1]; // in the first league: BREW; later: CAST, OPPONENT_CAST, LEARN, BREW
                int delta0 = int.Parse(inputs[2]); // tier-0 ingredient change
                int delta1 = int.Parse(inputs[3]); // tier-1 ingredient change
                int delta2 = int.Parse(inputs[4]); // tier-2 ingredient change
                int delta3 = int.Parse(inputs[5]); // tier-3 ingredient change
                int price = int.Parse(inputs[6]); // the price in rupees if this is a potion
                int tomeIndex = int.Parse(inputs[7]); // in the first two leagues: always 0; later: the index in the tome if this is a tome spell, equal to the read-ahead tax; For brews, this is the value of the current urgency bonus
                int taxCount = int.Parse(inputs[8]); // in the first two leagues: always 0; later: the amount of taxed tier-0 ingredients you gain from learning this spell; For brews, this is how many times you can still gain an urgency bonus
                bool castable = inputs[9] != "0"; // in the first league: always 0; later: 1 if this is a castable player spell
                bool repeatable = inputs[10] != "0"; // for the first two leagues: always 0; later: 1 if this is a repeatable player spell
                if(actionType == "CAST"){
                    int[] ingredients = {delta0, delta1, delta2, delta3};
                    Spell spell = new Spell(castable, ingredients, actionId, delta0 >= 0 && delta1 >= 0 && delta2 >= 0 && delta3 >= 0
                    ,repeatable);
                    if(FirstCastOrdersMe == null){
                        FirstCastOrdersMe = new Node<Spell>(spell);
                    }
                    else{
                        Node<Spell> LastCastOrderMe = FirstCastOrdersMe.GetLastNode(FirstCastOrdersMe);
                        LastCastOrderMe.Next = new Node<Spell>(spell);
                    }
                }
                else if(actionType == "OPPONENT_CAST"){
                    /*int[] ingredients = {delta0, delta1, delta2, delta3};
                    Spell spell = new Spell(castable, ingredients, actionId, delta0 >= 0 && delta1 >= 0 && delta2 >= 0 && delta3 >= 0
                    ,repeatable);
                    if(CastOrdersOpponent == null){
                        CastOrdersOpponent = new Node<Spell>(spell);
                    }
                    else{
                        CastOrdersOpponent.SetNext(new Node<Spell>(spell));
                        CastOrdersOpponent = CastOrdersOpponent.GetNext();
                    }*/
                }
                else if(actionType == "BREW"){
                    Node<string> LastCommand = FirstCommand.GetLastNode(FirstCommand);
                    if(FirstCommand != null && int.Parse(LastCommand.value.Split(" ")[1]) == actionId){
                        IsTargetExist = true;
                    }
                    int[] ingredients = {delta0, delta1, delta2, delta3};
                    Order order = new Order(ingredients, price, actionId);
                    if(FirstBrewOrders == null){
                        FirstBrewOrders = new Node<Order>(order);
                    }
                    else{
                        Node<Order> LastBrewOrder = FirstBrewOrders.GetLastNode(FirstBrewOrders);
                        LastBrewOrder.Next = new Node<Order>(order);
                    }
                }
                else{
                    if(IsLearnExist == false){
                        Node<string> PosCommand = FirstCommand;
                        while(PosCommand != null){
                            if(PosCommand.GetValue().Contains("Learn") && int.Parse(PosCommand.GetValue().Split(" ")[1]) == actionId){
                                IsLearnExist = true;
                                break;
                            }
                        }
                    }

                    int[] ingredients = {delta0, delta1, delta2, delta3};
                    LearnSpell learnSpell = new LearnSpell(castable, ingredients, actionId, repeatable, tomeIndex);
                    if(FirstLearningAbleCast == null){
                        FirstLearningAbleCast = new Node<LearnSpell>(learnSpell);
                    }
                    else{
                        Node<LearnSpell> LastLearningAbleCast = FirstLearningAbleCast.GetLastNode(FirstLearningAbleCast);
                        LastLearningAbleCast.Next = new Node<LearnSpell>(learnSpell);
                    }
                }
            }

            if(Learned != -1){
                Node<string> PosCommand = FirstCommand;
                while(PosCommand != null){
                    if(int.Parse(PosCommand.value) == Learned){
                        Node<Spell> LastCastOrderMe = FirstCastOrdersMe.GetLastNode(FirstCastOrdersMe);

                        PosCommand.value = "" + LastCastOrderMe.value.actionId;
                    }
                    else if(PosCommand.value.Contains("CAST")){
                        string[] Actions = PosCommand.value.Split(" ");

                        Node<Spell> LastCastOrderMe = FirstCastOrdersMe.GetLastNode(FirstCastOrdersMe);

                        PosCommand.value = "CAST " + LastCastOrderMe.value.actionId + " " + int.Parse(Actions[2]);
                    }

                    PosCommand = PosCommand.Next;
                }
                Learned = -1;
            }

            int[] CurrIngrMe = null;
            //int[] CurrIngrOp = new int[4];
            for (int i = 0; i < 2; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int inv0 = int.Parse(inputs[0]); // tier-0 ingredients in inventory
                int inv1 = int.Parse(inputs[1]);
                int inv2 = int.Parse(inputs[2]);
                int inv3 = int.Parse(inputs[3]);
                int score = int.Parse(inputs[4]); // amount of rupees
                if(i == 0){
                    CurrIngrMe = {inv0, inv1, inv2, inv3};
                    if(score != OldScoreMe){
                        OldScoreMe = score;
                        NumberOfPotionsMadeByMe++;
                    }
                }
                else{
                    //CurrIngrOp = {inv0, inv1, inv2, inv3};
                    if(score != OldScoreOp){
                        OldScoreOp = score;
                        NumberOfPotionsMadeByOp++;
                    }
                }
            }

            if(IsTargetExist == false || IsLearnExist == false){
                FirstCommand = null;
            }

            if(CanCastFromAllIngrs == false)
                CanCastFromAllIngrs = CanCastFromAllIngredients(FirstCastOrdersMe);

            if((Learn > 0 || CanCastFromAllIngrs == false) && Learn > 0){
                Console.WriteLine("LEARN " + FirstLearningAbleCast.value.actionId);
                Learn--;
                continue;
            }

            string[] Output = CanICastIngrAndThenBrewSpell(FirstLearningAbleCast, CurrIngrMe, FirstCastOrdersMe);
            if(Output[1] == "false"){
                int Index = int.Parse(Output[0]);
                if(Index != -1){

                    Node<Spell> CastOrderMe = FirstCastOrdersMe;

                    while(Index != 0){
                        CastOrderMe = CastOrderMe.Next;
                        Index--;
                    }

                    if(CastOrderMe.value.castable == true){
                        Console.WriteLine("CAST " + CastOrderMe.value.actionId + " Time: "+ (DateTime.Now.Millisecond - TimeNow));
                    }
                    else{
                        Console.WriteLine("REST Time: "+ (DateTime.Now.Millisecond - TimeNow));
                    }
                }
                else{
                    Console.WriteLine("REST Time: "+ (DateTime.Now.Millisecond - TimeNow));
                }
            }
            else{
                Console.Error.WriteLine();
                Console.Error.WriteLine("Price: "+CommandsPrice);
                if(Output[0] == "Rest"){
                    Console.WriteLine("REST Time: "+ (DateTime.Now.Millisecond - TimeNow));
                }
                else if(Output[0].Contains("Brew")){
                    int ActionId = int.Parse(Output[0].Split(' ')[1]);
                    Console.WriteLine("BREW " + ActionId + " Time: "+ (DateTime.Now.Millisecond - TimeNow));
                }
                else if(Output[0].Contains("CAST")){
                    string[] Actions = Output[0].Split(' ');
                    int times = int.Parse(Actions[2]);
                    int ActionId = int.Parse(Actions[1]);
                    Console.WriteLine("CAST " + ActionId + " " + times +  " Time: "+ (DateTime.Now.Millisecond - TimeNow));
                }
                else if(Output[0].Contains("Learn")){
                    int ActionId = int.Parse(Output[0].Split(" ")[1]);
                    Console.WriteLine("LEARN " + ActionId + " Yay!!!! Time: "+ (DateTime.Now.Millisecond - TimeNow));
                    Learned = ActionId;
                }
                else{
                    int ActionId = int.Parse(Output[0]);
                    Console.WriteLine("CAST " + ActionId + " Time: "+ (DateTime.Now.Millisecond - TimeNow));
                }
            }
        }
    }

    static void Recursive(int[] CurrIngreds, Node<Spell> FirstCastOrdersMe, Node<LearnSpell> FirstLearningAbleCast, int depth, Node<string> FirstStepPath){

        if(DateTime.Now.Millisecond - TimeNow >= 48){
            return;
        }

        /*if(HaveThisInventoryAlready(CurrIngreds)){
            Console.Error.WriteLine("ReduceTime!!!!")
            return;
        }

        let S = "" + CurrIngreds;

        InventoryRecursive.push(S);*/

        if(depth == 0){
            return;
        }

        //let SavedPath = Path.slice();

        Node<Spell> CastOrderMe = FirstCastOrdersMe;

        while(CastOrderMe != null){
            int NumberOfCasts = 1;
            if(CastOrderMe.value.castable == false){
                while(true){
                    int mone = 1;
                    if(NumberOfCasts > 1 && CastOrderMe.value.repeatable == false){
                        break;
                    }
                    int[] SumIngerds = GetSumIngredients(CastOrderMe.value.ingredients, CurrIngreds);
                    while(mone != NumberOfCasts){
                        SumIngerds = GetSumIngredients(CastOrderMe.value.ingredients, SumIngerds);
                        mone++;
                    }

                    if(SumIngerds != null){
                        int[] actionIdAndPrice = CanIBrewSpell(SumIngerds);
                        int actionId = actionIdAndPrice[0];
                        Node<string> LastStepPath = FirstStepPath.GetLastNode(FirstStepPath);
                        LastStepPath.Next.value = "Rest";
                        LastStepPath = LastStepPath.Next;
                        if(NumberOfCasts == 1)
                            LastStepPath.Next.value = "" + CastOrderMe.value.actionId;
                        else
                            LastStepPath.Next.value = "CAST " + CastOrderMe.value.actionId + " " + NumberOfCasts;

                        if(actionId != -1){
                            LastStepPath = LastStepPath.Next;
                            LastStepPath.Next.value = "Brew " + actionId;
                            int Price = actionIdAndPrice[1];
                            int SavedPrice = Price;

                            Node<Node<string>> PossiblesPaths = FirstPossiblesPaths;

                            while(Price != 0){
                                PossiblesPaths = PossiblesPaths.Next;
                                Price--;
                            }

                            if(PossiblesPaths[Price] == undefined){
                                PossiblesPaths[Price] = {Path, Price};
                            }
                            else if(PossiblesPaths[Price].length > Path.length){
                                PossiblesPaths[Price] = {Path, Price};
                            }
                            Path = SavedPath.slice();
                        }
                    }
                }
            }
        }

    }

    static int[] GetSumIngredients(int[] Ingredients1, int[] Ingredients2){

        int[] arr = new int[4];
        int sum = 0;

        for(int i = 0; i < Ingredients2.Length; i++){
            arr[i] = Ingredients2[i] + Ingredients1[i];
            sum += arr[i];
            if(arr[i] < 0){
                //I have negative ingredients
                return null;
            }
        }

        //Check if there are more than 10 ingredients 
        return sum > 10 ? null : arr;
    }

    static int[] CanIBrewSpell(int[] CurrIngrMe){

        int ActionId = -1;
        int MaxPrice = 0;

        Node<Order> BrewOrder = FirstBrewOrders;

        while(BrewOrder != null){
            int price = BrewOrder.value.price;

            if(GetSumIngredients(BrewOrder.value.ingredients, CurrIngrMe) != null
            && price > MaxPrice){
                MaxPrice = price;
                ActionId = BrewOrder.value.actionId;
            }
            BrewOrder = BrewOrder.Next;
        }
        return [ActionId, MaxPrice];
    }

}

/*     
                    
                    
                    else{
                        Recursive(SumIngerds, CastOrders, LearningAbleCast, depth - 1, Path);
                        Path = SavedPath.slice();
                    }

                    NumberOfCasts++;
                }
                else{
                    break;
                }
            }
        }
        else{
            while(true){
                let mone = 1;
                if(NumberOfCasts > 1 && CastOrders[i].repeatable == false){
                    break;
                }
                let SumIngerds = GetSumIngredients(CastOrders[i].ingredients, CurrIngreds);
                while(mone != NumberOfCasts){
                    SumIngerds = GetSumIngredients(CastOrders[i].ingredients, SumIngerds);
                    mone++;
                }

                if(SumIngerds != undefined){
                    let Index = CanIBrewSpell(SumIngerds);
                    if(NumberOfCasts == 1)
                        Path.push(CastOrders[i].actionId);
                    else
                        Path.push("CAST " + CastOrders[i].actionId + " " + NumberOfCasts);

                    if(Index != -1){
                        let Brew = "Brew " + BrewOrders[Index].actionId;
                        Path.push(Brew);
                        let Price = BrewOrders[Index].price;

                        if(PossiblesPaths[Price] == undefined){
                            PossiblesPaths[Price] = {Path, Price};
                        }
                        else if(PossiblesPaths[Price].length > Path.length){
                            PossiblesPaths[Price] = {Path, Price};
                        }
                        Path = SavedPath.slice();
                    }
                    else{
                        CastOrders[i].castable = false;
                        Recursive(SumIngerds, CastOrders, LearningAbleCast, depth - 1, Path);
                        CastOrders[i].castable = true;
                        Path = SavedPath.slice();
                    }
                }
                else{
                    break;
                }

                NumberOfCasts++;
            }
        }
    }

    for(let i = 0; i < LearningAbleCast.length; i++){
        let NumberOfCasts = 1;
        if(LearningAbleCast[i].tomeIndex > CurrIngreds[0]){
            continue;
        }
        while(true){
            let mone = 1;
            if(NumberOfCasts > 1 && LearningAbleCast[i].repeatable == false){
                break;
            }
            CurrIngreds[0] -= LearningAbleCast[i].tomeIndex;
            let SumIngerds = GetSumIngredients(LearningAbleCast[i].ingredients, CurrIngreds);
            CurrIngreds[0] += LearningAbleCast[i].tomeIndex;
            while(mone != NumberOfCasts){
                SumIngerds = GetSumIngredients(LearningAbleCast[i].ingredients, SumIngerds);
                mone++;
            }

            if(SumIngerds != undefined){
                let Index = CanIBrewSpell(SumIngerds);
                //Learn
                let Learn = "Learn " + LearningAbleCast[i].actionId;
                Path.push(Learn);
                //Cast
                if(NumberOfCasts == 1)
                    Path.push(LearningAbleCast[i].actionId);
                else
                    Path.push("CAST " +  LearningAbleCast[i].actionId + " " + NumberOfCasts);
                if(Index != -1){
                    let Brew = "Brew " + BrewOrders[Index].actionId;
                    Path.push(Brew);
                    let Price = BrewOrders[Index].price;
                    if(PossiblesPaths[Price] == undefined){
                        PossiblesPaths[Price] = {Path, Price};
                    }
                    else if(PossiblesPaths[Price].length > Path.length){
                        PossiblesPaths[Price] = {Path, Price};
                    }
                    Path = SavedPath.slice();
                }
                else{
                    let ListLearningAbleCast = LearningAbleCast.slice();
                    let LearnedSpell = ListLearningAbleCast.splice(i,1)[0];
                    LearnedSpell.castable = false;
                    CastOrders.push(LearnedSpell);
                    Recursive(SumIngerds, CastOrders, ListLearningAbleCast, depth - 1, Path);
                    Path = SavedPath.slice();
                    CastOrders.splice(CastOrders.length - 1,1);
                }
            }
            else{
                break;
            }

            NumberOfCasts++;
        }
    }
}

function CanICastIngrAndThenBrewSpell(LearningAbleCast, CurrIngrMe, CastOrdersMe){

    PossiblesPaths = [];

    InventoryRecursive = [];

    Recursive(CurrIngrMe, CastOrdersMe, LearningAbleCast, 4, []);
        
    //if(CastOrdersMe. length <= 12)
    //    Recursive(CurrIngrMe, CastOrdersMe, LearningAbleCast, 4, []);
    //else if(CastOrdersMe. length <= 30)
    //    Recursive(CurrIngrMe, CastOrdersMe, LearningAbleCast, 3, []);

    Console.Error.WriteLine("Commands: ")
    Console.Error.WriteLine(Commands)
    Console.Error.WriteLine()

    if(NumberOfPotionsMadeByOp == 5 || NumberOfPotionsMadeByMe == 5){
        if(OldScoreMe > OldScoreOp){
            //sort by shortest path
            PossiblesPaths.sort((a,b) => {
                return b.Price - a.Price;
            });
            //sort by shortest path
            PossiblesPaths.sort((a,b) => {
                return a.Path.length - b.Path.length;
            });
            //Console.Error.WriteLine("shortest PossiblesPaths: ");
            //Console.Error.WriteLine(PossiblesPaths);
            if(PossiblesPaths.length > 0){
                let BestPath = PossiblesPaths[0].Path;
                let BestPrice = PossiblesPaths[0].Price;
                if(Commands.length == 0 || 
                Commands.length > BestPath.length ||
                (Commands.length == BestPath.length &&
                CommandsPrice < BestPrice)){
                    Commands = BestPath;
                    CommandsPrice = BestPrice;
                    return [Commands.splice(0,1)[0], true];
                }
                else{
                    return [Commands.splice(0,1)[0], true];
                }
            }
        }
    }


    //sort
    PossiblesPaths.sort((a,b) => {
        return (b.Price / b.Path.length) - (a.Price / a.Path.length);
    });

    Console.Error.WriteLine("PossiblesPaths: ");
    Console.Error.WriteLine(PossiblesPaths);   

    if(PossiblesPaths.length > 0){
        let BestPath = PossiblesPaths[0].Path;
        let BestPrice = PossiblesPaths[0].Price;

        if(Commands.length == 0){
            Commands = BestPath;
            CommandsPrice = BestPrice;
            return [Commands.splice(0,1)[0], true];
        }
        else{
            if((BestPrice / BestPath.length) > (CommandsPrice / Commands.length)){
                //Console.Error.WriteLine("CHANGE!!!!!!!!!!!!!!")
                Commands = BestPath;
                CommandsPrice = BestPrice;
                return [Commands.splice(0,1)[0], true];
            }
            else
                return [Commands.splice(0,1)[0], true];
        }
    }

    /*let Max = 0;

    let Index = -1;
    
    for(let i = 0; i < CastOrdersMe.length; i++){
        let CastIngredients = CastOrdersMe[i].ingredients;
        let SumIngredients = GetSumIngredients(CastIngredients, CurrIngrMe);
        if(SumIngredients != undefined){
            let M = SumIngredients[0] + SumIngredients[1] +
            SumIngredients[2] + SumIngredients[3];
            if(M > Max){
                Max = M;
                Index = i;
            }
        }
    }

    return [Index, false];

    let Min = 100;

    let Index = -1;

    for(let i = 0; i < CastOrdersMe.length; i++){

        let CastIngredients = CastOrdersMe[i].ingredients;

        let SumIngredients = GetSumIngredients(CastIngredients, CurrIngrMe);
        if(SumIngredients != undefined){
            let CurrMin = 0;
            
            //Find the biggest differnce between ingredients
            for(let i = 0; i < SumIngredients.length; i++){
                let ingrA = SumIngredients[i];
                for(let j = i + 1; j < SumIngredients.length; j++){
                    let ingrB = SumIngredients[j];
                    let diff = Math.abs(ingrA - ingrB);
                    if(diff > CurrMin){
                        CurrMin = diff;
                    }
                }
            }
            

            if(CurrMin >= Min){
                continue;
            }
            
            Min = CurrMin;
            Index = i;
        }
    }

    return [Index, false];
}

function HaveThisInventoryAlready(CurrIngreds){

    let s = "" + CurrIngreds;

    for(let i = 0; i < InventoryRecursive.length; i++){
        if(InventoryRecursive == s){
            return true;
        }
    }

    return false;
}


function CanCastFromAllIngredients(CastOrdersMe){

    let CanCastIngrs = Array(4).fill(0);

    CastOrdersMe.forEach((x) => {
        x.ingredients.forEach((v, index) => {
            if(v < 0){
                CanCastIngrs[index] = 1;
            }
        })

    })

    return CanCastIngrs.every(x => x == 1);
}

/*function GetIndexOfId(set, id){

    for(let i = 0; i < set.length; i++){
        if(set[i].actionId == id){
            return i;
        }
    }
    return -1;
}

*/
