/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/

class Order{

    constructor(Cost, price, actionId){
        this.Cost = Cost;
        this.Price = price;
        this.Id = actionId;
    }

}

class Spell{

    constructor(Cost, actionId, castable, repeatable){
        this.Cost = Cost;
        this.Id = actionId;
        this.Castable = castable;
        this.Repeatable = repeatable;
    }

}

class LearnSpell{

    constructor(Cost, actionId, repeatable, tomeIndex, taxCount){
        this.Cost = Cost;
        this.Id = actionId;
        this.Repeatable = repeatable;
        this.TomeIndex = tomeIndex;
        this.TaxCount = taxCount;
    }

}

class Player{

    constructor(inventory, score, spells){
        this.Inventory = inventory;
        this.Score = score;
        this.NumberOfOrderProvided = 0;
        this.Spells = spells;
    }
}

let Me = new Player([], 0, []);
let Op = new Player([], 0, []);

let PossiblesPaths = [];
let PossiblesPathsOp = [];

let CurrentPath = [];
let CurrentPrice = 0;

let States = [];

let Learn = 9;

let Time = 0;

let Global_Path = [];

// game loop
while (true) {
    const actionCount = parseInt(readline()); // the number of spells and recipes in play
    Time = Date.now();
    let Orders = [];
    let LearnableSpells = [];
    Me.Spells = [];
    Op.Spells = [];

    for (let i = 0; i < actionCount; i++) {
        var inputs = readline().split(' ');
        const actionId = parseInt(inputs[0]); // the unique ID of this spell or recipe
        const actionType = inputs[1]; // in the first league: BREW; later: CAST, OPPONENT_CAST, LEARN, BREW
        const delta0 = parseInt(inputs[2]); // tier-0 ingredient change
        const delta1 = parseInt(inputs[3]); // tier-1 ingredient change
        const delta2 = parseInt(inputs[4]); // tier-2 ingredient change
        const delta3 = parseInt(inputs[5]); // tier-3 ingredient change
        const price = parseInt(inputs[6]); // the price in rupees if this is a potion
        const tomeIndex = parseInt(inputs[7]); // in the first two leagues: always 0; later: the index in the tome if this is a tome spell, equal to the read-ahead tax; For brews, this is the value of the current urgency bonus
        const taxCount = parseInt(inputs[8]); // in the first two leagues: always 0; later: the amount of taxed tier-0 ingredients you gain from learning this spell; For brews, this is how many times you can still gain an urgency bonus
        const castable = inputs[9] !== '0'; // in the first league: always 0; later: 1 if this is a castable player spell
        const repeatable = inputs[10] !== '0'; // for the first two leagues: always 0; later: 1 if this is a repeatable player spell
        if(actionType == "BREW"){
            Orders.push(new Order([delta0, delta1, delta2, delta3], price, actionId));
        }
        else if(actionType == "CAST"){
            Me.Spells.push(new Spell([delta0, delta1, delta2, delta3], actionId, castable, repeatable));
        }
        else if(actionType == "OPPONENT_CAST"){
            Op.Spells.push(new Spell([delta0, delta1, delta2, delta3], actionId, castable, repeatable));
        }
        else{
            LearnableSpells.push(new LearnSpell([delta0, delta1, delta2, delta3], actionId, repeatable, tomeIndex, taxCount));
        }
    }

    for (let i = 0; i < 2; i++) {
        var inputs = readline().split(' ');
        const inv0 = parseInt(inputs[0]); // tier-0 ingredients in inventory
        const inv1 = parseInt(inputs[1]);
        const inv2 = parseInt(inputs[2]);
        const inv3 = parseInt(inputs[3]);
        const score = parseInt(inputs[4]); // amount of rupees
        if(i == 0){
            if(score != Me.Score)
                Me.NumberOfOrderProvided++;
            Me.Inventory = [inv0, inv1, inv2, inv3];
            Me.Score = score;
        }
        else{
            if(score != Op.Score)
                Op.NumberOfOrderProvided++;
            Op.Inventory = [inv0, inv1, inv2, inv3];
            Op.Score = score;
        }
    }

    if(Learn > 0){
        let ID = GetIdLearn(LearnableSpells, Me.Inventory[0]);
        if(ID != -1){
            console.log("LEARN " + ID);
            Learn--;
            continue;
        }
    }

    PossiblesPaths = [];
    Global_Path = [];

    Sim(Me.Inventory, Me.Spells, Orders, LearnableSpells, 4, 0);

    PossiblesPathsOp = [];
    Global_Path = [];

    SimOp(Op.Inventory, Op.Spells, Orders, 1, 0);

    PossiblesPathsOp.sort((a,b) => a.Path.length - b.Path.length);

    /*console.error("PossiblesPathsOp: ");
    for(let i = 0; i < PossiblesPathsOp.length; i++){
        if(PossiblesPathsOp[i] == undefined) break;
        console.error(PossiblesPathsOp[i].Path);
        console.error("Price: " + PossiblesPathsOp[i].Price);
        console.error();
    }*/

    //console.error("CurrentPath: ")
    //console.error(CurrentPath)
    //console.error()

    PossiblesPaths.sort((a,b) => b.Price / b.Path.length - a.Price / a.Path.length)
    //PossiblesPaths.sort((a,b) => b.Price - a.Price)
    /*console.error("PossiblesPaths: ");
    for(let i = 0; i < PossiblesPaths.length; i++){
        if(PossiblesPaths[i] == undefined) break;
        console.error(PossiblesPaths[i].Path);
        console.error("Price: " + PossiblesPaths[i].Price);
        console.error();
    }*/

    if(PossiblesPaths.length > 0 && (CurrentPath.length == 0 || (PossiblesPaths[0].Price / PossiblesPaths[0].Path.length > CurrentPrice / CurrentPath.length) ||
    (CurrentPath.length != 0 && TargetOrderIsNotExist(CurrentPath[CurrentPath.length - 1].actionId, Orders)))){
        //console.error("Change Path!!!")
        CurrentPath = PossiblesPaths[0].Path;
        CurrentPrice = PossiblesPaths[0].Price;
    }

    if(Me.NumberOfOrderProvided == 5 || Op.NumberOfOrderProvided == 5){
        PossiblesPaths.sort((a,b) => b.Path.length - a.Path.length);
        PossiblesPaths.sort((a,b) => b.Price - a.Price);

        let Non_BlueOp = GetNumberOfNon_BluesInInventory(Op.Inventory);

        let Index = -1;
        let BestLen = 100000;

        if(CurrentPrice + Me.Score > Op.Score + Non_BlueOp){
            BestLen = CurrentPath.length;
        }

        for(let i = 0; i < PossiblesPaths.length; i++){
            if(PossiblesPaths[i] == undefined) break;
            if(PossiblesPaths[i].Price + Me.Score > Op.Score + Non_BlueOp
            && PossiblesPaths[i].Path.length < BestLen){
                BestLen = PossiblesPaths[i].Path.length;
                Index = i;
            }
        }
        //console.error("Index: "+Index)
        //console.error()
        
        if(Index != -1){
            //console.error("PossiblesPaths[Index]")
            //console.error(PossiblesPaths[Index])
            //console.error()
            CurrentPath = PossiblesPaths[Index].Path;
            CurrentPrice = PossiblesPaths[Index].Price;
        }
    }

    let c = false;

    for(let j = 0; j < PossiblesPathsOp.length; j++){
        let P = PossiblesPathsOp[j];
        if(P == undefined) break;
        if(CurrentPath[CurrentPath.length - 1].actionId == P.Path[P.Path.length - 1].actionId && 
        CurrentPath.length > P.Path.length){
            //console.error("My Id: " +CurrentPath[CurrentPath.length - 1].actionId);
            //console.error("Op Id: " +P.Path[P.Path.length - 1].actionId);
            //console.error("CurrentPath.length: " +CurrentPath.length);
            //console.error("P.Path.length: " +P.Path.length);
            c = true;
            //console.error("CHANGE C!!!!!")
            break;
        }
    }

    if(c){
        let index = 0;

        let check = true;

        while(check && CurrentPath.length != 0){
            check = false;
            if(PossiblesPaths[index] == undefined){
                CurrentPath = [];
                CurrentPrice = 0;
                break;
            }
            CurrentPath = PossiblesPaths[index].Path;
            CurrentPrice = PossiblesPaths[index].Price;

            for(let j = 0; j < PossiblesPathsOp.length; j++){
                let P = PossiblesPathsOp[j];
                if(P == undefined) break;
                if(CurrentPath[CurrentPath.length - 1].actionId == P.Path[P.Path.length - 1].actionId && 
                CurrentPath.length > P.Path.length){
                    check = true;
                    //console.error("CHANGE!!!!!")
                    break;
                }
            }
            index++;
        }
    }

    //console.error("CurrentPath: ")
    //console.error(CurrentPath)
    //console.error()

    if(CurrentPath.length != 0){
        let Step = CurrentPath.splice(0,1)[0];
        //console.error("Step: ")
        //console.error(Step);
        if(Step.Action == "CAST" && Step.Times != undefined){
            console.log(Step.Action + " " + Step.actionId + " " + Step.Times + " Time: "+(Date.now() - Time));
        }
        else if(Step.Action == "REST"){
            console.log(Step.Action + " Time: "+(Date.now() - Time));
        }
        else{
            console.log(Step.Action + " " + Step.actionId + " Time: "+(Date.now() - Time));
        }
    }
    else{
        let res = DoASpell(Me.Inventory, Me.Spells);
        if(res == undefined){
            console.log("REST");
        }
    }

    // in the first league: BREW <id> | WAIT; later: BREW <id> | CAST <id> [<times>] | LEARN <id> | REST | WAIT
}

function GetNumberOfNon_BluesInInventory(Inventory){

    let s = 0;

    for(let i = 1; i < Inventory.length; i++){
        s += Inventory[i];
    }

    return s;
}

function GetIdLearn(LearnableSpells, NumberOfBlues){

    let Max = -1000;
    let BestId = -1;

    for(let i = 0; i < LearnableSpells.length; i++){
        let LearnableSpell = LearnableSpells[i];

        let cost = 0;

        for(let j = 0; j < LearnableSpell.Cost.length; j++){
            if(LearnableSpell.Cost[j] < 0){
                cost += LearnableSpell.Cost[j] * -1;
            }
        }

        if(LearnableSpell.TomeIndex > NumberOfBlues || cost > 4) continue;

        let Values = [1, 2, 3, 4];

        let gain = 0;
        cost = 0;

        for(let j = 0; j < LearnableSpell.Cost.length; j++){
            if(LearnableSpell.Cost[j] < 0){
                cost += LearnableSpell.Cost[j] * -1 * Values[j];
            }
            else if(LearnableSpell.Cost[j] > 0){
                gain += LearnableSpell.Cost[j] * Values[j];
            }
        }

        let diff = gain - cost;

        if(diff > Max){
            Max = diff;
            BestId = LearnableSpell.Id;
        }

    }

    return BestId;

}

function DoASpell(Inventory, Spells){

    for(let i = 0; i < Spells.length; i++){
        if(Spells[i].Castable == false) continue;
        let SumInvn = Combine(Inventory, Spells[i].Cost);
        if(SumInvn != undefined){
            console.log("CAST " + Spells[i].Id);
            return 1;
        }
    }

}

function SimOp(inventory, spells, orders, depth, Price){

    if(depth == 0) return;

    if(Date.now() - Time >= 49) return;

    for(let i = 0; i < spells.length; i++){
        let spell = spells[i];
        let NumberOfCast = 1;

        if(spell.Castable){
            while(true){
                if(NumberOfCast > 1 && !spell.Repeatable){
                    break;
                }
                let mone = 1;
                let SumInventory = Combine(inventory, spell.Cost);
                while(mone < NumberOfCast){
                    SumInventory = Combine(SumInventory, spell.Cost);
                    mone++;
                }

                if(SumInventory != undefined){
                    let Index = CanProvideOrder(SumInventory, orders);

                    if(NumberOfCast == 1)
                        Global_Path.push({Action: "CAST", actionId: spell.Id});
                    else
                        Global_Path.push({Action: "CAST", actionId: spell.Id, Times: NumberOfCast});

                    if(Index != -1){
                        let price = orders[Index].Price;
                        let ActionId = orders[Index].Id;
                        Global_Path.push({Action: "BREW", actionId: ActionId});

                        Price += price;

                        if(PossiblesPathsOp[price] == undefined || 
                        PossiblesPathsOp[price].Path.length > Global_Path.length){
                            PossiblesPathsOp[price] = {Path: Global_Path.slice(), Price};
                        }

                        SumInventory = Combine(SumInventory, orders[Index].Cost);

                        let NextSpells = [];
                        for(let i = 0; i < spells.length; i++){
                            NextSpells[i] = Object.assign({}, spells[i])
                        }
                        NextSpells[i].Castable = false;
                        Sim(SumInventory, NextSpells, orders, depth - 1, Price);

                        Price -= price;

                        Global_Path.splice(Global_Path.length - 1,1);
                    }
                    else{
                        let NextSpells = [];
                        for(let i = 0; i < spells.length; i++){
                            NextSpells[i] = Object.assign({}, spells[i])
                        }
                        NextSpells[i].Castable = false;
                        Sim(SumInventory, NextSpells, orders, depth - 1, Price);
                    }

                    Global_Path.splice(Global_Path.length - 1,1);

                }
                else{
                    break;
                }

                NumberOfCast++;
            }
        }
        else{
            while(true){
                if(NumberOfCast > 1 && !spell.Repeatable){
                    break;
                }

                let mone = 1;

                let SumInventory = Combine(inventory, spell.Cost);

                while(mone < NumberOfCast){
                    SumInventory = Combine(SumInventory, spell.Cost);
                    mone++;
                }

                if(SumInventory != undefined){
                    let Index = CanProvideOrder(SumInventory, orders);

                    Global_Path.push({Action: "REST"});

                    if(NumberOfCast == 1)
                        Global_Path.push({Action: "CAST", actionId: spell.Id});
                    else
                        Global_Path.push({Action: "CAST", actionId: spell.Id, Times: NumberOfCast});

                    if(Index != -1){
                        let price = orders[Index].Price;
                        let ActionId = orders[Index].Id;
                        Global_Path.push({Action: "BREW", actionId: ActionId});

                        Price += price;

                        if(PossiblesPathsOp[price] == undefined || 
                        PossiblesPathsOp[price].Path.length > Global_Path.length){
                            PossiblesPathsOp[price] = {Path: Global_Path.slice(), Price};
                        }

                        SumInventory = Combine(SumInventory, orders[Index].Cost);

                        let NextSpells = [];
                        for(let i = 0; i < spells.length; i++){
                            NextSpells[i] = Object.assign({}, spells[i])
                            NextSpells[i].Castable = true;
                        }
                        NextSpells[i].Castable = false;
                        Sim(SumInventory, NextSpells, orders, depth - 1, Price);

                        Price -= price;

                        Global_Path.splice(Global_Path.length - 1,1);
                    }
                    else{
                        let NextSpells = [];
                        for(let i = 0; i < spells.length; i++){
                            NextSpells[i] = Object.assign({}, spells[i])
                            NextSpells[i].Castable = true;
                        }
                        NextSpells[i].Castable = false;
                        Sim(SumInventory, NextSpells, orders, depth - 1, Price);
                    }
                    
                    Global_Path.splice(Global_Path.length - 2, 2);

                }
                else{
                    break;
                }

                NumberOfCast++;
            }
        }
    }

}

function Sim(inventory, spells, orders, LearnSpells, depth, Price){

    if(depth == 0) return;

    if(Date.now() - Time >= 49) return;

    for(let i = 0; i < spells.length; i++){
        let spell = spells[i];
        let NumberOfCast = 1;

        if(spell.Castable){
            while(true){
                if(NumberOfCast > 1 && !spell.Repeatable){
                    break;
                }
                let mone = 1;
                let SumInventory = Combine(inventory, spell.Cost);
                while(mone < NumberOfCast){
                    SumInventory = Combine(SumInventory, spell.Cost);
                    mone++;
                }

                if(SumInventory != undefined){
                    let Index = CanProvideOrder(SumInventory, orders);

                    if(NumberOfCast == 1)
                        Global_Path.push({Action: "CAST", actionId: spell.Id});
                    else
                        Global_Path.push({Action: "CAST", actionId: spell.Id, Times: NumberOfCast});

                    if(Index != -1){
                        let price = orders[Index].Price;
                        let ActionId = orders[Index].Id;
                        Global_Path.push({Action: "BREW", actionId: ActionId});

                        Price += price;

                        if(PossiblesPaths[price] == undefined || 
                        PossiblesPaths[price].Path.length > Global_Path.length){
                            PossiblesPaths[price] = {Path: Global_Path.slice(), Price};
                        }

                        SumInventory = Combine(SumInventory, orders[Index].Cost);

                        let NextSpells = [];
                        for(let j = 0; j < spells.length; j++){
                            NextSpells[j] = Object.assign({}, spells[j])
                        }
                        NextSpells[i].Castable = false;

                        /*let TempOrders = [];
                        for(let j = 0; j < spells.length; j++){
                            if(j == i) continue;
                            TempOrders.push(Object.assign({}, orders[j]))
                        }
                        Sim(SumInventory, NextSpells, TempOrders, LearnSpells, depth - 1, Price);*/
                        Sim(SumInventory, NextSpells, orders, LearnSpells, depth - 1, Price)

                        Price -= price;

                        Global_Path.splice(Global_Path.length - 1,1);
                    }
                    else{
                        let NextSpells = [];
                        for(let j = 0; j < spells.length; j++){
                            NextSpells[j] = Object.assign({}, spells[j])
                        }
                        NextSpells[i].Castable = false;
                        Sim(SumInventory, NextSpells, orders, LearnSpells, depth - 1, Price);
                    }

                    Global_Path.splice(Global_Path.length - 1,1);

                }
                else{
                    break;
                }

                NumberOfCast++;
            }
        }
        else{
            while(true){
                if(NumberOfCast > 1 && !spell.Repeatable){
                    break;
                }

                let mone = 1;

                let SumInventory = Combine(inventory, spell.Cost);

                while(mone < NumberOfCast){
                    SumInventory = Combine(SumInventory, spell.Cost);
                    mone++;
                }

                if(SumInventory != undefined){
                    let Index = CanProvideOrder(SumInventory, orders);

                    Global_Path.push({Action: "REST"});

                    if(NumberOfCast == 1)
                        Global_Path.push({Action: "CAST", actionId: spell.Id});
                    else
                        Global_Path.push({Action: "CAST", actionId: spell.Id, Times: NumberOfCast});

                    if(Index != -1){
                        let price = orders[Index].Price;
                        let ActionId = orders[Index].Id;
                        Global_Path.push({Action: "BREW", actionId: ActionId});

                        Price += price;

                        if(PossiblesPaths[price] == undefined || 
                        PossiblesPaths[price].Path.length > Global_Path.length){
                            PossiblesPaths[price] = {Path: Global_Path.slice(), Price};
                        }

                        SumInventory = Combine(SumInventory, orders[Index].Cost);

                        let NextSpells = [];
                        for(let j = 0; j < spells.length; j++){
                            NextSpells[j] = Object.assign({}, spells[j])
                            NextSpells[j].Castable = true;
                        }
                        NextSpells[i].Castable = false;

                        /*let TempOrders = [];
                        for(let j = 0; j < spells.length; j++){
                            if(j == i) continue;
                            TempOrders.push(Object.assign({}, orders[j]))
                        }
                        Sim(SumInventory, NextSpells, TempOrders, LearnSpells, depth - 1, Price);*/
                        Sim(SumInventory, NextSpells, orders, LearnSpells, depth - 1, Price)

                        Price -= price;

                        Global_Path.splice(Global_Path.length - 1,1);
                    }
                    else{
                        let NextSpells = [];
                        for(let j = 0; j < spells.length; j++){
                            NextSpells[j] = Object.assign({}, spells[j])
                            NextSpells[j].Castable = true;
                        }
                        NextSpells[i].Castable = false;
                        Sim(SumInventory, NextSpells, orders, LearnSpells, depth - 1, Price);
                    }
                    
                    Global_Path.splice(Global_Path.length - 2, 2);

                }
                else{
                    break;
                }

                NumberOfCast++;
            }
        }
    }

    /*for(let i = 0 ; i < LearnSpells.length; i++){
        let spell = LearnSpells[i];
        let NumberOfCast = 1;

        while(true){
            if(NumberOfCast > 1 && !spell.Repeatable){
                break;
            }
            let mone = 1;
            let SumInventory = Combine(inventory, spell.Cost);
            while(mone < NumberOfCast){
                SumInventory = Combine(SumInventory, spell.Cost);
                mone++;
            }
            if(SumInventory != undefined){
                let Index = CanProvideOrder(SumInventory, orders);
                Global_Path.push({Action: "LEARN", actionId: spell.Id});

                if(NumberOfCast == 1)
                    Global_Path.push({Action: "CAST", actionId: spell.Id});
                else
                    Global_Path.push({Action: "CAST", actionId: spell.Id, Times: NumberOfCast});

                if(Index != -1){
                    let price = orders[Index].Price;
                    let ActionId = orders[Index].Id;
                    Global_Path.push({Action: "BREW", actionId: ActionId});

                    Price += price;

                    if(PossiblesPaths[price] == undefined || 
                    PossiblesPaths[price].Path.length > Global_Path.length){
                        PossiblesPaths[price] = {Path: Global_Path.slice(), Price};
                    }

                    SumInventory = Combine(SumInventory, orders[Index].Cost);

                    let NextSpells = [];
                    for(let j = 0; j < spells.length; j++){
                        NextSpells[j] = Object.assign({}, spells[j])
                    }
                    spell.Castable = false;
                    NextSpells.push(spell);
                    let TempLearnSpells = [];
                    for(let j = 0; j < LearnSpells.length; j++){
                        if(j == i) continue;
                        TempLearnSpells[j] = Object.assign({}, LearnSpells[j]);
                    }
                    Sim(SumInventory, NextSpells, orders, TempLearnSpells, depth - 1, Price);

                    Price -= price;

                    Global_Path.splice(Global_Path.length - 1,1);
                }
                else{
                    let NextSpells = [];
                    for(let j = 0; j < spells.length; j++){
                        NextSpells[j] = Object.assign({}, spells[j])
                    }
                    NextSpells[i].Castable = false;
                    Sim(SumInventory, NextSpells, orders, depth - 1, Price);
                }

                Global_Path.splice(Global_Path.length - 1,1);
            }
            else{
                break;
            }
            NumberOfCast++;
        }
    }*/

}

function CanProvideOrder(inventory, orders){

    let maxPrice = -10000;
    let Index = -1;

    for(let i = 0; i < orders.length; i++){
        let order = orders[i];
        let SumInventory = Combine(inventory, order.Cost);
        if(SumInventory != undefined && maxPrice < order.Price){
            Index = i;
            maxPrice = order.Price;
        }
    }

    return Index;
}

function Combine(inventory1, inventory2){

    let arr = [];
    let sum = 0;

    for(let i = 0; i < inventory1.length; i++){
        arr[i] = inventory1[i] + inventory2[i];
        if(arr[i] < 0) return undefined;
        sum += arr[i];
    }

    if(sum > 10) return undefined;

    return arr;
}

function TargetOrderIsNotExist(actionId, orders){

    for(let i = 0; i < orders.length; i++){
        if(orders[i].Id == actionId) return false;
    }

    return true;
}
